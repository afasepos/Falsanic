"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonDatabaseAdapter = void 0;
const path_1 = __importDefault(require("path"));
const BaseDatabaseAdapter_1 = require("../BaseDatabaseAdapter");
const promises_1 = require("fs/promises");
const lodash_1 = require("lodash");
const fs_1 = require("fs");
;
class JsonDatabaseAdapter extends BaseDatabaseAdapter_1.BaseDatabaseAdapter {
    _raw = { giveaways: [], entries: [] };
    file = path_1.default.join(process.cwd(), 'giveaways.json');
    parser = JSON;
    get data() {
        return {
            giveaways: this._raw.giveaways.map(g => JsonDatabaseAdapter.parseGiveaway(g)),
            entries: this._raw.entries.map(e => JsonDatabaseAdapter.parseGiveawayEntry(e))
        };
    }
    ;
    get giveaways() { return this.data.giveaways; }
    get entries() { return this.data.entries; }
    constructor(options) {
        super();
        this.file = options?.file ? path_1.default.resolve(options.file) : this.file;
        this.parser = options?.parser ? options.parser : this.parser;
    }
    async fetchJson() {
        if (!(0, fs_1.existsSync)(this.file))
            return this.saveJson();
        const data = this.parser.parse(await (0, promises_1.readFile)(this.file, 'utf-8'));
        this._raw = data;
        return data;
    }
    async saveJson(data) {
        data ??= this._raw;
        await (0, promises_1.mkdir)(path_1.default.dirname(this.file), { recursive: true });
        await (0, promises_1.writeFile)(this.file, this.parser.stringify(data));
        return data;
    }
    async fetchGiveaways(options) {
        await this.fetchJson();
        return (options?.filter ? (0, lodash_1.filter)(this.giveaways, options.filter) : this.giveaways).splice(0, options?.count ?? Infinity);
    }
    async fetchGiveaway(giveawayId) {
        await this.fetchJson();
        return this.giveaways.find(g => g.id === giveawayId);
    }
    async createGiveaway(data) {
        await this.fetchJson();
        const isExists = this.giveaways.some(g => g.id === data.id || g.messageId === data.messageId);
        if (isExists)
            throw new Error('Unable to create new giveaway! given id or messageId is already used');
        this._raw.giveaways.push(JsonDatabaseAdapter.parseGiveaway(data));
        await this.saveJson();
        const giveaway = this.giveaways.find(g => g.id === data.id);
        if (!giveaway)
            throw new Error('Unable to create new giveaway! Json file did not save');
        return giveaway;
    }
    async updateGiveaway(giveawayId, data) {
        const giveaway = await this.fetchGiveaway(giveawayId);
        if (!giveaway)
            throw new Error(`Unable to update giveaway! Giveaway id not found: ${giveawayId}`);
        const giveawayIndex = this.giveaways.findIndex(g => g.id === giveawayId);
        const newGiveaway = JsonDatabaseAdapter.parseGiveaway({
            ...giveaway,
            ...data
        });
        this._raw.giveaways[giveawayIndex] = newGiveaway;
        await this.saveJson();
        return JsonDatabaseAdapter.parseGiveaway(newGiveaway);
    }
    async deleteGiveaway(filter, count) {
        const findFirst = typeof filter === 'string';
        filter = typeof filter === 'string' ? { id: filter } : filter;
        await this.fetchJson();
        const giveaways = (0, lodash_1.filter)(this.giveaways, filter).splice(0, count ?? Infinity);
        this._raw.giveaways = this._raw.giveaways.filter(g => !giveaways.some(d => d.id === g.id));
        this._raw.entries = this._raw.entries.filter(e => !giveaways.some(d => d.id === e.giveawayId));
        await this.saveJson();
        return findFirst ? giveaways[0] : giveaways;
    }
    async fetchGiveawayEntries(options) {
        await this.fetchJson();
        return (options?.filter ? (0, lodash_1.filter)(this.entries, options.filter) : this.entries).splice(0, options?.count ?? Infinity);
    }
    async fetchGiveawayEntry(entryId) {
        await this.fetchJson();
        return this.entries.find(e => e.id === entryId);
    }
    async createGiveawayEntry(giveawayId, data) {
        const giveaway = await this.fetchGiveaway(giveawayId);
        if (!giveaway)
            throw new Error(`Unable to create giveaway entry! Giveaway id not found: ${giveawayId}`);
        const isExists = this.entries.find(e => e.id === data.id || (e.giveawayId === data.giveawayId && e.userId === data.userId));
        if (isExists)
            throw new Error('Unable to create giveaway entry! Entry id already exists');
        this._raw.entries.push(JsonDatabaseAdapter.parseGiveawayEntry(data));
        await this.saveJson();
        const entry = this.entries.find(e => e.id === data.id);
        if (!entry)
            throw new Error('Unable to create new entry! Json file did not save');
        return entry;
    }
    async updateGiveawayEntry(entryId, data) {
        const entry = await this.fetchGiveawayEntry(entryId);
        if (!entry)
            throw new Error(`Unable to entry! Entry id not found: ${entryId}`);
        const entryIndex = this._raw.entries.findIndex(e => e.id === entryId);
        const newEntry = JsonDatabaseAdapter.parseGiveawayEntry({
            ...entry,
            ...data
        });
        this._raw.entries[entryIndex] = newEntry;
        await this.saveJson();
        return JsonDatabaseAdapter.parseGiveawayEntry(newEntry);
    }
    async deleteGiveawayEntry(filter, count) {
        const findFirst = typeof filter === 'string';
        filter = typeof filter === 'string' ? { id: filter } : filter;
        await this.fetchJson();
        const entries = (0, lodash_1.filter)(this.entries, filter).splice(0, count ?? Infinity);
        this._raw.entries = this._raw.entries.filter(e => !entries.some(d => d.id === e.id));
        await this.saveJson();
        return findFirst ? entries[0] : entries;
    }
    static parseGiveaway(giveaway) {
        return {
            ...giveaway,
            createdAt: this.parseDate(giveaway.createdAt),
            endedAt: (giveaway.endedAt ? this.parseDate(giveaway.endedAt) : null),
            endsAt: this.parseDate(giveaway.endsAt)
        };
    }
    static parseGiveawayEntry(entry) {
        return {
            ...entry,
            createdAt: this.parseDate(entry.createdAt),
        };
    }
    static parseDate(date) {
        return typeof date === 'string' ? new Date(date) : date.toISOString();
    }
}
exports.JsonDatabaseAdapter = JsonDatabaseAdapter;
//# sourceMappingURL=JsonDatabaseAdapter.js.map