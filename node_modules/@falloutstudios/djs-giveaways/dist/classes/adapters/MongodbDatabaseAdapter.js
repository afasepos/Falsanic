"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongodbDatabaseAdapter = void 0;
const mongoose_1 = require("mongoose");
const BaseDatabaseAdapter_1 = require("../BaseDatabaseAdapter");
const discord_js_1 = require("discord.js");
const lodash_1 = require("lodash");
class MongodbDatabaseAdapter extends BaseDatabaseAdapter_1.BaseDatabaseAdapter {
    options;
    mongoose;
    giveawaysModel;
    giveawayEntriesModel;
    constructor(options) {
        super();
        this.options = options;
    }
    async start(manager) {
        if (typeof this.options.mongooseConnection !== 'string') {
            this.mongoose ??= this.options.mongooseConnection;
        }
        else {
            const mongoose = await import('mongoose');
            this.mongoose ??= await mongoose.connect(this.options.mongooseConnection);
        }
        this.giveawaysModel = this.options.giveawaysModel ?? this.mongoose.model('Giveaways', this.giveawaySchema, 'Giveaways');
        this.giveawayEntriesModel = this.options.giveawayEntriesModel ?? this.mongoose.model('GiveawayEntries', this.giveawayEntrySchema, 'GiveawayEntries');
        await super.start(manager);
    }
    async fetchGiveaways(options) {
        const data = await this.giveawaysModel.find({
            ...(options?.filter ? MongodbDatabaseAdapter.parseGiveawayObject(options.filter) : {})
        }, null, { limit: options?.count });
        return data.map(d => MongodbDatabaseAdapter.parseGiveawayDocument(d));
    }
    async fetchGiveaway(giveawayId) {
        const data = await this.giveawaysModel.findOne({
            id: giveawayId
        });
        return data ? MongodbDatabaseAdapter.parseGiveawayDocument(data) : undefined;
    }
    async createGiveaway(data) {
        const newData = await this.giveawaysModel.create(MongodbDatabaseAdapter.parseGiveawayObject(data));
        return MongodbDatabaseAdapter.parseGiveawayDocument(newData);
    }
    async updateGiveaway(giveawayId, data) {
        const updated = await this.giveawaysModel.updateOne({ id: giveawayId }, MongodbDatabaseAdapter.parseGiveawayObject(data));
        if (!updated.modifiedCount)
            throw new Error(`Unable to update giveaway! Giveaway id not found: ${giveawayId}`);
        return (await this.fetchGiveaway(giveawayId));
    }
    async deleteGiveaway(filter, count) {
        const findFirst = typeof filter === 'string';
        filter = typeof filter === 'string' ? { id: filter } : filter;
        const giveaways = await this.fetchGiveaways({ filter, count: findFirst ? 1 : count });
        if (!giveaways.length)
            return findFirst ? giveaways[0] : giveaways;
        await this.giveawayEntriesModel.deleteMany({
            $or: giveaways.map(e => ({ giveaway_id: e.id }))
        });
        await this.giveawaysModel.deleteMany({
            $or: giveaways.map(g => ({ id: g.id }))
        });
        return findFirst ? giveaways[0] : giveaways;
    }
    async fetchGiveawayEntries(options) {
        const data = await this.giveawayEntriesModel.find({
            ...(options?.filter ? MongodbDatabaseAdapter.parseGiveawayEntryObject(options?.filter) : {})
        }, null, { limit: options?.count });
        return data.map(d => MongodbDatabaseAdapter.parseGiveawayEntryDocument(d));
    }
    async fetchGiveawayEntry(entryId) {
        const data = await this.giveawayEntriesModel.findOne({
            id: entryId
        });
        return data ? MongodbDatabaseAdapter.parseGiveawayEntryDocument(data) : undefined;
    }
    async createGiveawayEntry(giveawayId, data) {
        const giveaway = await this.fetchGiveaway(giveawayId);
        if (!giveaway)
            throw new Error(`Unable to create new giveaway`);
        const newData = await this.giveawayEntriesModel.create(MongodbDatabaseAdapter.parseGiveawayEntryObject(data));
        return MongodbDatabaseAdapter.parseGiveawayEntryDocument(newData);
    }
    async updateGiveawayEntry(entryId, data) {
        const updated = await this.giveawayEntriesModel.updateOne({ id: entryId }, MongodbDatabaseAdapter.parseGiveawayEntryObject(data));
        if (!updated.modifiedCount)
            throw new Error(`Unable to update giveaway entry! Entry id not found: ${entryId}`);
        return (await this.fetchGiveawayEntry(entryId));
    }
    async deleteGiveawayEntry(filter, count) {
        const findFirst = typeof filter === 'string';
        filter = typeof filter === 'string' ? { id: filter } : filter;
        const entries = await this.fetchGiveawayEntries({ filter, count: findFirst ? 1 : count });
        if (!entries.length)
            return findFirst ? entries[0] : entries;
        await this.giveawayEntriesModel.deleteMany({
            $or: entries.map(e => ({ id: e.id }))
        });
        return findFirst ? entries[0] : entries;
    }
    // Static
    static parseGiveawayDocument(document) {
        const data = (0, discord_js_1.isJSONEncodable)(document) ? document.toJSON() : document;
        return {
            id: data.id,
            guildId: data.guild_id,
            channelId: data.channel_id,
            messageId: data.message_id,
            authorId: data.author_id,
            name: data.name,
            winnerCount: data.winner_count,
            endsAt: data.ends_at,
            createdAt: data.created_at,
            ended: data.ended ?? false,
            endedAt: data.ended_at ?? null,
            winnersEntryId: data.winners_entry_id,
        };
    }
    static parseGiveawayObject(data) {
        data = (0, discord_js_1.isJSONEncodable)(data) ? data.toJSON() : data;
        return (0, lodash_1.mapKeys)(data, (value, key) => (0, lodash_1.snakeCase)(key));
    }
    static parseGiveawayEntryDocument(document) {
        const data = (0, discord_js_1.isJSONEncodable)(document) ? document.toJSON() : document;
        return {
            id: data.id,
            giveawayId: data.giveaway_id,
            userId: data.user_id,
            createdAt: data.created_at,
        };
    }
    static parseGiveawayEntryObject(data) {
        data = (0, discord_js_1.isJSONEncodable)(data) ? data.toJSON() : data;
        return (0, lodash_1.mapKeys)(data, (value, key) => (0, lodash_1.snakeCase)(key));
    }
    static ObjectId = mongoose_1.Schema.ObjectId;
    static giveawaySchema = new mongoose_1.Schema({
        id: { type: String, required: true },
        guild_id: { type: String, required: true },
        channel_id: { type: String, required: true },
        message_id: { type: String, required: true },
        author_id: String,
        name: { type: String, required: true },
        winner_count: { type: Number, required: true },
        ends_at: { type: Date, required: true },
        created_at: { type: Date, required: true, default: Date.now },
        ended: { type: Boolean, required: true, default: false },
        ended_at: Date,
        winners_entry_id: [
            { type: String, required: true }
        ],
    });
    static giveawayEntrySchema = new mongoose_1.Schema({
        id: { type: String, required: true },
        giveaway_id: { type: String, required: true },
        user_id: { type: String, required: true },
        created_at: { type: Date, required: true, default: Date.now },
    });
    giveawaySchema = MongodbDatabaseAdapter.giveawaySchema;
    giveawayEntrySchema = MongodbDatabaseAdapter.giveawayEntrySchema;
}
exports.MongodbDatabaseAdapter = MongodbDatabaseAdapter;
//# sourceMappingURL=MongodbDatabaseAdapter.js.map