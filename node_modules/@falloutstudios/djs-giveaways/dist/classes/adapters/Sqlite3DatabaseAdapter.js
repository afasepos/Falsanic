"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sqlite3DatabaseAdapter = void 0;
const console_1 = require("console");
const BaseDatabaseAdapter_1 = require("../BaseDatabaseAdapter");
const path_1 = __importDefault(require("path"));
class Sqlite3DatabaseAdapter extends BaseDatabaseAdapter_1.BaseDatabaseAdapter {
    file = path_1.default.join(process.cwd(), 'giveaways.db');
    database;
    constructor(options) {
        super();
        try {
            require.resolve('better-sqlite3');
        }
        catch (err) {
            throw new Error('Unable to find required dependency: better-sqlite3');
        }
        this.file = options?.file ?? this.file;
        this.database = require('better-sqlite3')(this.file, options?.databaseOptions);
    }
    async start(manager) {
        this.database.exec(`
            CREATE TABLE IF NOT EXISTS "Giveaways" (
                "id" TEXT NOT NULL PRIMARY KEY,
                "guildId" TEXT NOT NULL,
                "channelId" TEXT NOT NULL,
                "messageId" TEXT NOT NULL,
                "authorId" TEXT,
                "name" TEXT NOT NULL,
                "winnerCount" INTEGER NOT NULL DEFAULT 1,
                "endsAt" DATETIME NOT NULL,
                "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
                "ended" BOOLEAN NOT NULL DEFAULT false,
                "endedAt" DATETIME,
                "winnersEntryId" TEXT NOT NULL DEFAULT "[]"
            );

            CREATE TABLE IF NOT EXISTS "GiveawayEntries" (
                "id" TEXT NOT NULL PRIMARY KEY,
                "giveawayId" TEXT NOT NULL,
                "userId" TEXT NOT NULL,
                "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT "GiveawayEtries_giveawayId_fkey" FOREIGN KEY ("giveawayId") REFERENCES "Giveaways" ("id") ON DELETE CASCADE ON UPDATE CASCADE
            );

            CREATE UNIQUE INDEX IF NOT EXISTS "Giveaways_id_key" ON "Giveaways"("id");
            CREATE UNIQUE INDEX IF NOT EXISTS "Giveaways_messageId_key" ON "Giveaways"("messageId");
            CREATE UNIQUE INDEX IF NOT EXISTS "GiveawayEtries_id_key" ON "GiveawayEntries"("id");
        `);
        await super.start(manager);
    }
    async fetchGiveaways(options) {
        let query = `SELECT * FROM 'Giveaways'`;
        let values = [];
        if (options?.filter) {
            query += ` WHERE`;
            Object.keys(options.filter).forEach((key, index) => {
                let value = (options.filter ?? {})[key];
                if (value === undefined)
                    return;
                value = Sqlite3DatabaseAdapter.parseValue(value);
                query += ` ${index ? 'AND ' : ''}${key} = ?`;
                values.push(value);
            });
        }
        if (typeof options?.count === 'number') {
            query += `LIMIT ${console_1.count}`;
        }
        return this.database.prepare(query).all(...values).map(g => Sqlite3DatabaseAdapter.parseGiveaway(g));
    }
    async fetchGiveaway(giveawayId) {
        const data = this.database.prepare(`SELECT * FROM 'Giveaways' WHERE id = ?`).get(giveawayId);
        return data ? Sqlite3DatabaseAdapter.parseGiveaway(data) : undefined;
    }
    async createGiveaway(data) {
        this.database.prepare(`INSERT INTO 'Giveaways' VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(data.id, data.guildId, data.channelId, data.messageId, data.authorId, data.name, data.winnerCount, data.endsAt.toISOString(), data.createdAt.toISOString(), String(data.ended), data.endedAt?.toISOString() ?? null, JSON.stringify(data.winnersEntryId));
        return data;
    }
    async updateGiveaway(giveawayId, data) {
        const giveaway = await this.fetchGiveaway(giveawayId);
        if (!giveaway)
            throw new Error(`Unable to update giveaway! Giveaway id not found: ${giveawayId}`);
        const newGiveaway = {
            ...giveaway,
            ...data
        };
        let query = `UPDATE 'Giveaways'`;
        let values = [];
        let keys = Object.keys(data);
        if (keys.length) {
            query += ` SET`;
            keys.forEach((key, index) => {
                let value = (data ?? {})[key];
                if (value === undefined)
                    return;
                value = Sqlite3DatabaseAdapter.parseValue(value);
                query += ` ${key} = ?${key !== (keys[keys.length - 1]) ? ',' : ''}`;
                values.push(value);
            });
        }
        query += ` WHERE id = ?`;
        values.push(giveawayId);
        const updated = this.database.prepare(query).run(...values).changes;
        if (!updated)
            throw new Error('Unable to update giveaway! No changes found');
        return newGiveaway;
    }
    async deleteGiveaway(filter, count) {
        const findFirst = typeof filter === 'string';
        filter = typeof filter === 'string' ? { id: filter } : filter;
        const giveaways = await this.fetchGiveaways({ filter, count: findFirst ? 1 : count });
        if (!giveaways.length)
            return findFirst ? giveaways[0] : giveaways;
        let query = `DELETE FROM 'Giveaways'`;
        let values = [];
        if (giveaways.length) {
            query += ' WHERE';
            giveaways.forEach((giveaway, index) => {
                query += ` id = ?${index !== (giveaways.length - 1) ? ' OR' : ''}`;
                values.push(giveaway.id);
            });
        }
        this.database.prepare(query).run(...values);
        return findFirst ? giveaways[0] : giveaways;
    }
    async fetchGiveawayEntries(options) {
        let query = `SELECT * FROM 'GiveawayEntries'`;
        let values = [];
        if (options?.filter) {
            query += ` WHERE`;
            Object.keys(options.filter).forEach((key, index) => {
                let value = (options.filter ?? {})[key];
                if (value === undefined)
                    return;
                value = Sqlite3DatabaseAdapter.parseValue(value);
                query += ` ${index ? 'AND ' : ''}${key} = ?`;
                values.push(value);
            });
        }
        if (typeof options?.count === 'number') {
            query += `LIMIT ${console_1.count}`;
        }
        return this.database.prepare(query).all(...values).map(g => Sqlite3DatabaseAdapter.parseGiveawayEntry(g));
    }
    async fetchGiveawayEntry(entryId) {
        const data = this.database.prepare(`SELECT * FROM 'GiveawayEntries' WHERE id = ?`).get(entryId);
        return data ? Sqlite3DatabaseAdapter.parseGiveawayEntry(data) : undefined;
    }
    async createGiveawayEntry(giveawayId, data) {
        const giveaway = await this.fetchGiveaway(giveawayId);
        if (!giveaway)
            throw new Error(`Unable to create new giveaway`);
        this.database.prepare(`INSERT INTO 'GiveawayEntries' VALUES (?, ?, ?, ?)`).run(data.id, data.giveawayId, data.userId, data.createdAt.toISOString());
        return data;
    }
    async updateGiveawayEntry(entryId, data) {
        const entry = await this.fetchGiveawayEntry(entryId);
        if (!entry)
            throw new Error(`Unable to update entry! Entry id not found: ${entryId}`);
        const newEntry = {
            ...entry,
            ...data
        };
        let query = `UPDATE 'GiveawayEntries'`;
        let values = [];
        let keys = Object.keys(data);
        if (keys.length) {
            query += ` SET`;
            keys.forEach((key, index) => {
                let value = (data ?? {})[key];
                if (value === undefined)
                    return;
                value = Sqlite3DatabaseAdapter.parseValue(value);
                query += ` ${key} = ?${key !== (keys[keys.length - 1]) ? ',' : ''}`;
                values.push(value);
            });
        }
        query += ` WHERE id = ?`;
        values.push(entryId);
        const updated = this.database.prepare(query).run(...values).changes;
        if (!updated)
            throw new Error('Unable to update entry! No changes found');
        return newEntry;
    }
    async deleteGiveawayEntry(filter, count) {
        const findFirst = typeof filter === 'string';
        filter = typeof filter === 'string' ? { id: filter } : filter;
        const entries = await this.fetchGiveawayEntries({ filter, count: findFirst ? 1 : count });
        if (!entries.length)
            return findFirst ? entries[0] : entries;
        let query = `DELETE FROM 'GiveawayEntries'`;
        let values = [];
        if (entries.length) {
            query += ' WHERE';
            entries.forEach((entry, index) => {
                query += ` id = ?${index !== (entries.length - 1) ? ' OR' : ''}`;
                values.push(entry.id);
            });
        }
        this.database.prepare(query).run(...values);
        return findFirst ? entries[0] : entries;
    }
    static parseGiveaway(giveaway) {
        return {
            ...giveaway,
            createdAt: this.parseDate(giveaway.createdAt),
            endedAt: (giveaway.endedAt ? this.parseDate(giveaway.endedAt) : null),
            ended: typeof giveaway.ended === 'string' ? (giveaway.ended === 'true') : giveaway.ended,
            endsAt: this.parseDate(giveaway.endsAt),
            winnersEntryId: typeof giveaway.winnersEntryId === 'string'
                ? JSON.parse(giveaway.winnersEntryId)
                : JSON.stringify(giveaway.winnersEntryId)
        };
    }
    static parseGiveawayEntry(entry) {
        return {
            ...entry,
            createdAt: this.parseDate(entry.createdAt),
        };
    }
    static parseDate(date) {
        return typeof date === 'string' ? new Date(date) : date.toISOString();
    }
    static parseValue(value) {
        if (value instanceof Date)
            return this.parseDate(value);
        if (Array.isArray(value))
            return JSON.stringify(value);
        if (value === null)
            return null;
        if (value === undefined)
            return '';
        if (typeof value === 'number')
            return value;
        if (typeof value === 'boolean')
            return value === true ? 'true' : 'false';
        return String(value);
    }
}
exports.Sqlite3DatabaseAdapter = Sqlite3DatabaseAdapter;
//# sourceMappingURL=Sqlite3DatabaseAdapter.js.map