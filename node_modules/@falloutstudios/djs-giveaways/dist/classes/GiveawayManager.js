"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GiveawayManager = void 0;
const discord_js_1 = require("discord.js");
const fallout_utility_1 = require("fallout-utility");
const GiveawayError_1 = require("./GiveawayError");
const crypto_1 = require("crypto");
const utils_1 = require("@reciple/utils");
class GiveawayManager extends fallout_utility_1.TypedEmitter {
    client;
    databaseAdapter;
    giveawayTimouts = new discord_js_1.Collection();
    joinButtonCustomId = 'giveaway-join';
    onBeforeHandleInteraction = () => true;
    _ready = false;
    constructor(options) {
        super();
        this.client = options.client;
        this.databaseAdapter = options.databaseAdapter;
        this.joinButtonCustomId = options.joinButtonCustomId ?? this.joinButtonCustomId;
        this._err = this._err.bind(this);
        this._guildDelete = this._guildDelete.bind(this);
        this._channelDelete = this._channelDelete.bind(this);
        this._messageDelete = this._messageDelete.bind(this);
        this._messageDeleteBulk = this._messageDeleteBulk.bind(this);
        this._interactionCreate = this._interactionCreate.bind(this);
    }
    /**
     * Toggles user's giveaway entry
     * @param giveawayId The giveaway id
     * @param userId The user id
     * @param updateMessage Updates the giveaway message
     * @returns Returns a giveaway entry data if entry is added, null if removed
     */
    async toggleGiveawayEntry(giveawayId, userId, updateMessage = true) {
        if (!this._ready)
            throw new GiveawayError_1.GiveawayError('Giveaway manager is not ready');
        let entries = await this.databaseAdapter.fetchGiveawayEntries({ filter: { giveawayId } });
        let entry = entries.find(e => e.userId === userId) ?? null;
        if (entry) {
            await this.databaseAdapter.deleteGiveawayEntry(entry.id);
            entries = entries.filter(e => entry?.id !== e.id);
            this.emit('giveawayEntryDelete', entry, giveawayId);
            entry = null;
        }
        else {
            entry = await this.databaseAdapter.createGiveawayEntry(giveawayId, {
                id: this.createDataId(),
                createdAt: new Date(),
                giveawayId,
                userId
            });
            entries.push(entry);
            this.emit('giveawayEntryAdd', entry, giveawayId);
        }
        if (updateMessage) {
            const giveaway = await this.databaseAdapter.fetchGiveaway(giveawayId);
            if (!giveaway)
                throw new GiveawayError_1.GiveawayError(`Giveaway id not found: ${giveawayId}`);
            const message = await this.getGiveawayMessage(giveaway);
            if (!message) {
                await this.databaseAdapter.deleteGiveaway(giveawayId);
                throw new GiveawayError_1.GiveawayError(`Giveaway message not found!`);
            }
            await message.edit(await this.createGiveawayMessageOptions({
                ...giveaway,
                entries: entries.length
            }));
        }
        return entry;
    }
    /**
     * Creates a giveaway
     * @param options Giveaway options
     * @returns The giveaway message
     */
    async createGiveaway(options) {
        if (!this._ready)
            throw new GiveawayError_1.GiveawayError('Giveaway manager is not ready');
        const createdAt = new Date();
        const endsAt = typeof options.endsAt === 'number' ? new Date(Date.now() + options.endsAt) : options.endsAt;
        const duration = typeof options.endsAt === 'number' ? options.endsAt : options.endsAt.getTime() - Date.now();
        const channel = options.channel;
        if (!isFinite(duration) || isNaN(duration) || duration === 0 || duration > 2147483647)
            throw new GiveawayError_1.GiveawayError('Duration must be a positive number below or equal to 25 days (32 bit integer limit)');
        const data = {
            name: options.name,
            authorId: options.authorId,
            winnerCount: options.winnerCount ?? 1,
            createdAt,
            endsAt,
            ended: false,
            endedAt: null,
            winnersEntryId: [],
            entries: 0,
        };
        const message = await channel.send({
            ...(await this.createGiveawayMessageOptions(data)),
            content: options.content
        });
        data.entries = undefined;
        const giveaway = await this.databaseAdapter.createGiveaway({
            ...data,
            id: this.createDataId(),
            guildId: message.guildId,
            channelId: message.channelId,
            messageId: message.id
        }).catch(async (err) => {
            message.delete().catch(() => null);
            throw err;
        });
        this.createGiveawayTimeout(giveaway.id, endsAt);
        this.emit('giveawayCreate', giveaway);
        return message;
    }
    /**
     * Ends a giveaway
     * @param giveawayId The giveaway id
     * @param fetchWinnerEntries Fetch winner entries
     * @returns Returns the giveaway winners if fetchWinnerEntries is enabled
     */
    async endGiveaway(giveawayId, fetchWinnerEntries = true) {
        if (!this._ready)
            throw new GiveawayError_1.GiveawayError('Giveaway manager is not ready');
        this.deleteGiveawayTimeout(giveawayId);
        const giveaway = await this.databaseAdapter.fetchGiveaway(giveawayId);
        const entries = await Promise.all((giveaway?.winnersEntryId ?? []).map(e => this.databaseAdapter.fetchGiveawayEntry(e)).filter(Boolean));
        if (!giveaway || giveaway.ended)
            return entries;
        const winners = fetchWinnerEntries
            ? await this.getRandomGiveawayEntries(giveawayId, giveaway.winnerCount)
            : { entries: await this.databaseAdapter.fetchGiveawayEntries({ filter: { giveawayId } }), selected: [] };
        const message = await this.getGiveawayMessage(giveaway);
        if (!message) {
            await this.databaseAdapter.deleteGiveaway(giveawayId);
            throw new GiveawayError_1.GiveawayError('Giveaway message not found');
        }
        const endedGiveaway = await this.databaseAdapter.updateGiveaway(giveawayId, {
            ...giveaway,
            ended: true,
            endedAt: new Date(),
            endsAt: new Date(),
            winnersEntryId: winners.selected.map(s => s.id) ?? []
        });
        this.emit('giveawayEnd', giveaway, winners);
        await message.edit(await this.createGiveawayMessageOptions({
            ...endedGiveaway,
            entries: winners.entries.length ?? 0
        }));
        return winners.selected;
    }
    /**
     * Deletes giveaway
     * @param giveawayId The giveaway id
     * @returns Returns the deleted giveaway if there's any
     */
    async deleteGiveaway(giveawayId) {
        if (!this._ready)
            throw new GiveawayError_1.GiveawayError('Giveaway manager is not ready');
        this.deleteGiveawayTimeout(giveawayId);
        const giveaway = await this.databaseAdapter.fetchGiveaway(giveawayId);
        if (!giveaway)
            return;
        const message = await this.getGiveawayMessage(giveaway);
        await message?.delete();
        await this.databaseAdapter.deleteGiveaway(giveawayId);
        this.emit('giveawayDelete', giveaway);
        return giveaway;
    }
    /**
     * Creates a giveaway message options
     * @param giveaway Giveaway data
     * @returns The giveaway message options
     */
    async createGiveawayMessageOptions(giveaway) {
        const embed = new discord_js_1.EmbedBuilder();
        embed.setTitle(giveaway.name);
        embed.setAuthor({ name: '🎉 Giveaway' });
        embed.setColor(giveaway.ended ? 'DarkButNotBlack' : 'Blue');
        embed.addFields({ name: `${(0, discord_js_1.inlineCode)('⏲️')} End${giveaway.ended ? 'ed' : 's'}`, value: (0, discord_js_1.time)(giveaway.endsAt, 'R') + (!giveaway.ended ? ` (${(0, discord_js_1.time)(giveaway.endsAt)})` : '') });
        embed.addFields({ name: `${(0, discord_js_1.inlineCode)('👥')} Entries`, value: `${giveaway.entries ? (0, discord_js_1.inlineCode)(giveaway.entries.toLocaleString('en-US')) : '**No entries**'}` });
        embed.setFooter({ text: giveaway.ended ? 'Ended' : 'Active' });
        embed.setTimestamp(giveaway?.endedAt ?? giveaway.createdAt);
        let isDisabled = false;
        const entries = giveaway.winnersEntryId.length && giveaway.id ? await this.databaseAdapter.fetchGiveawayEntries({ filter: { giveawayId: giveaway.id } }) : [];
        const winners = giveaway.winnersEntryId.length
            ? giveaway.winnersEntryId.map(id => entries.find(e => e.id === id)?.userId).filter((e) => !!e)
            : [];
        if (giveaway.ended) {
            embed.addFields({
                name: ((0, discord_js_1.inlineCode)('🏆') + ' Winner') + (winners.length > 1 ? 's' : ''),
                value: !winners.length ? (0, discord_js_1.inlineCode)('none') : winners.map(id => `${(0, discord_js_1.userMention)(id)} ${(0, discord_js_1.inlineCode)(id)}`).join('\n')
            });
            isDisabled = true;
        }
        return {
            content: giveaway.ended
                ? winners.length
                    ? (0, discord_js_1.inlineCode)('🎉') + winners.map((id, i) => (i == winners.length && winners.length > 1 ? 'and ' : '') + (0, discord_js_1.userMention)(id)).join(' ') + ' won the giveaway!'
                    : 'There is no winner for this giveaway'
                : undefined,
            embeds: [embed.toJSON()],
            components: [
                {
                    type: discord_js_1.ComponentType.ActionRow,
                    components: [
                        new discord_js_1.ButtonBuilder()
                            .setCustomId(this.joinButtonCustomId)
                            .setDisabled(isDisabled)
                            .setStyle(discord_js_1.ButtonStyle.Primary)
                            .setEmoji('🎉')
                            .toJSON()
                    ]
                }
            ]
        };
    }
    /**
     * Get random entries from a giveaway
     * @param giveawayId The giveaway id
     * @param winnerCount Count of selected entries
     * @returns Returns the selected winners and entries
     */
    async getRandomGiveawayEntries(giveawayId, winnerCount = 1) {
        if (!this._ready)
            throw new GiveawayError_1.GiveawayError('Giveaway manager is not ready');
        const entries = await this.databaseAdapter.fetchGiveawayEntries({ filter: { giveawayId } });
        const selected = [];
        if (entries.length) {
            winnerCount = winnerCount > entries.length ? entries.length : winnerCount;
            for (let i = 0; i < winnerCount; i++) {
                const entry = (0, fallout_utility_1.getRandomKey)(entries.filter(e => !selected.some(s => s.id === e.id)));
                if (entry)
                    selected.push(entry);
            }
        }
        return { entries, selected };
    }
    /**
     * Get message of a giveaway
     * @param giveaway The giveaway data
     * @returns The giveaway message if there's any
     */
    async getGiveawayMessage(giveaway) {
        const guild = await (0, utils_1.resolveFromCachedCollection)(giveaway.guildId, this.client.guilds).catch(() => null);
        if (!guild)
            return;
        const channel = await (0, utils_1.resolveFromCachedCollection)(giveaway.channelId, guild.channels).catch(() => null);
        if (!channel || !channel.isTextBased())
            return;
        const message = await (0, utils_1.resolveFromCachedCollection)(giveaway.messageId, channel.messages).catch(() => null);
        if (!message)
            return;
        return message;
    }
    /**
     * Clean deleted giveaways from database
     * @param giveaways Giveaways to clean
     * @returns Returns the deleted giveaways
     */
    async clean(giveaways) {
        if (!this._ready)
            throw new GiveawayError_1.GiveawayError('Giveaway manager is not ready');
        giveaways ??= await this.databaseAdapter.fetchGiveaways();
        const cleaned = [];
        for (const giveaway of giveaways) {
            const message = await this.getGiveawayMessage(giveaway);
            if (!message) {
                await this.databaseAdapter.deleteGiveaway(giveaway.id);
                cleaned.push(giveaway);
            }
        }
        return cleaned;
    }
    /**
     * Starts the giveaway manager
     */
    async start() {
        if (!this.client.isReady())
            throw new GiveawayError_1.GiveawayError('Discord.js client is not yet ready or logged in');
        await this.databaseAdapter.start(this);
        this.databaseAdapter.on('error', this._err);
        this.client.on('guildDelete', this._guildDelete);
        this.client.on('channelDelete', this._channelDelete);
        this.client.on('messageDelete', this._messageDelete);
        this.client.on('messageDeleteBulk', this._messageDeleteBulk);
        this.client.on('interactionCreate', this._interactionCreate);
        this._ready = true;
        const giveaways = await this.databaseAdapter.fetchGiveaways({ filter: { ended: false } });
        for (const giveaway of giveaways) {
            await this.createGiveawayTimeout(giveaway.id, giveaway.endsAt).catch(err => this.emit(err));
        }
    }
    /**
     * Destroy the giveaway manager
     */
    destroy() {
        this._ready = false;
        this.databaseAdapter.removeListener('error', this._err);
        this.client.removeListener('guildDelete', this._guildDelete);
        this.client.removeListener('channelDelete', this._channelDelete);
        this.client.removeListener('messageDelete', this._messageDelete);
        this.client.removeListener('messageDeleteBulk', this._messageDeleteBulk);
        this.client.removeListener('interactionCreate', this._interactionCreate);
        for (const [id, timeout] of this.giveawayTimouts) {
            clearTimeout(timeout.timeout);
            this.giveawayTimouts.delete(id);
        }
    }
    createDataId() {
        return (0, crypto_1.randomBytes)(10).toString('hex');
    }
    async createGiveawayTimeout(giveawayId, endsAt) {
        if (endsAt.getTime() <= Date.now()) {
            this.endGiveaway(giveawayId);
            return;
        }
        const timer = endsAt.getTime() - Date.now();
        const timeout = setTimeout(() => this.endGiveaway(giveawayId).catch(err => this.emit('error', err)), timer).unref();
        this.giveawayTimouts.set(giveawayId, { giveawayId, timeout });
    }
    deleteGiveawayTimeout(giveawayId) {
        const timeout = this.giveawayTimouts.get(giveawayId);
        if (timeout) {
            clearTimeout(timeout.timeout);
            this.giveawayTimouts.delete(giveawayId);
        }
    }
    async _guildDelete(guild) {
        try {
            const giveaways = await this.databaseAdapter.deleteGiveaway({ guildId: guild.id });
            for (const giveaway of giveaways) {
                await this.endGiveaway(giveaway.id);
            }
        }
        catch (err) {
            this.emit('error', err);
        }
    }
    async _channelDelete(channel) {
        try {
            const giveaways = await this.databaseAdapter.deleteGiveaway({ channelId: channel.id });
            for (const giveaway of giveaways) {
                await this.endGiveaway(giveaway.id);
            }
        }
        catch (err) {
            this.emit('error', err);
        }
    }
    async _messageDelete(message) {
        try {
            const giveaways = await this.databaseAdapter.deleteGiveaway({ messageId: message.id });
            for (const giveaway of giveaways) {
                await this.endGiveaway(giveaway.id);
            }
        }
        catch (err) {
            this.emit('error', err);
        }
    }
    async _messageDeleteBulk(messages) {
        for (const message of messages.values()) {
            await this._messageDelete(message);
        }
    }
    async _interactionCreate(interaction) {
        if (!interaction.isButton() || interaction.customId !== this.joinButtonCustomId)
            return;
        const deffered = await interaction.deferReply({ ephemeral: true }).catch(err => this.emit('error', err));
        if (!deffered)
            return;
        try {
            const allowed = await Promise.resolve(this.onBeforeHandleInteraction(interaction));
            if (allowed === false)
                return;
            const message = interaction.message;
            const giveaways = await this.databaseAdapter.fetchGiveaways({ filter: { messageId: message.id } });
            const giveaway = giveaways[0];
            if (!giveaway) {
                await interaction.editReply(`${(0, discord_js_1.inlineCode)('❌')} Unable to find giveaway from this message`);
                return;
            }
            const entry = await this.toggleGiveawayEntry(giveaway.id, interaction.user.id).catch(() => undefined);
            if (entry === undefined) {
                await interaction.editReply(`${(0, discord_js_1.inlineCode)('❌')} Unable to add/remove entry`);
                return;
            }
            if (entry) {
                await interaction.editReply(`${(0, discord_js_1.inlineCode)('🎉')} Successfully added new entry!`);
            }
            else {
                await interaction.editReply(`${(0, discord_js_1.inlineCode)('🎉')} Successfully removed current entry!`);
            }
        }
        catch (err) {
            this.emit('error', err);
        }
    }
    _err(err) {
        this.emit('error', err);
    }
}
exports.GiveawayManager = GiveawayManager;
//# sourceMappingURL=GiveawayManager.js.map