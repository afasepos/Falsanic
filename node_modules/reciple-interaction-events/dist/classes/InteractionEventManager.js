"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionEventManager = void 0;
const listeners_1 = require("../types/listeners");
const InteractionEventListenerError_1 = require("./InteractionEventListenerError");
const discord_js_1 = require("discord.js");
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
class InteractionEventManager {
    packageJson = JSON.parse((0, node_fs_1.readFileSync)(node_path_1.default.join(__dirname, '../../package.json'), 'utf-8'));
    moduleName = this.packageJson.name;
    versions = this.packageJson.peerDependencies['@reciple/client'];
    client;
    logger;
    constructor() {
        this.emitInteraction = this.emitInteraction.bind(this);
    }
    async onStart(client) {
        this.client = client;
        this.logger = client.logger?.clone({ name: 'InteractionEventManager' });
        return true;
    }
    async onLoad() {
        this.client.on('interactionCreate', this.emitInteraction);
    }
    async onUnload() {
        this.client.removeListener('interactionCreate', this.emitInteraction);
    }
    async emitInteraction(interaction) {
        let scripts = this.client.modules.modules.map(s => s.script);
        const commandType = this.getInteractionListenerType(interaction);
        for (const script of scripts) {
            if (!script.interactionListeners?.length)
                continue;
            const listeners = script.interactionListeners.map(l => (0, discord_js_1.isJSONEncodable)(l) ? l.toJSON() : l);
            for (const listener of listeners) {
                if (listener.type !== commandType)
                    continue;
                try {
                    if (this.isAnyCommandInteractionListener(listener)) {
                        if (!await this.satisfiesCommandName(interaction, listener))
                            continue;
                    }
                    else if (this.isAnyComponentInteractionListener(listener)) {
                        if (!await this.satisfiesCustomId(interaction, listener))
                            continue;
                    }
                    // @ts-expect-error Never type
                    await Promise.resolve(listener.execute(interaction));
                }
                catch (err) {
                    this.client._throwError(new InteractionEventListenerError_1.InteractionEventListenerError({
                        message: 'An error occured while executing an interaction event listener.',
                        cause: err,
                        listenerType: listeners_1.InteractionListenerType[listener.type]
                    }));
                }
            }
        }
    }
    getInteractionListenerType(interaction) {
        if (interaction.isAutocomplete()) {
            return listeners_1.InteractionListenerType.Autocomplete;
        }
        else if (interaction.isChatInputCommand()) {
            return listeners_1.InteractionListenerType.ChatInput;
        }
        else if (interaction.isContextMenuCommand()) {
            return listeners_1.InteractionListenerType.ContextMenu;
        }
        else if (interaction.isButton()) {
            return listeners_1.InteractionListenerType.Button;
        }
        else if (interaction.isModalSubmit()) {
            return listeners_1.InteractionListenerType.ModalSubmit;
        }
        else if (interaction.isAnySelectMenu()) {
            return listeners_1.InteractionListenerType.SelectMenu;
        }
        else {
            throw new Error('Unknown interaction type');
        }
    }
    async satisfiesCommandName(interaction, listener) {
        if (!listener.commandName)
            return true;
        return typeof listener.commandName === 'string'
            ? listener.commandName === interaction.commandName
            // @ts-expect-error 
            : listener.commandName(interaction);
    }
    async satisfiesCustomId(interaction, listener) {
        if (!listener.customId)
            return true;
        return typeof listener.customId === 'string'
            ? listener.customId === interaction.customId
            // @ts-expect-error
            : listener.customId(interaction);
    }
    isAnyCommandInteractionListener(listener) {
        return listener.type === listeners_1.InteractionListenerType.Autocomplete || listener.type === listeners_1.InteractionListenerType.ChatInput || listener.type === listeners_1.InteractionListenerType.ContextMenu;
    }
    isAnyComponentInteractionListener(listener) {
        return listener.type === listeners_1.InteractionListenerType.Button || listener.type === listeners_1.InteractionListenerType.ModalSubmit || listener.type === listeners_1.InteractionListenerType.SelectMenu;
    }
}
exports.InteractionEventManager = InteractionEventManager;
//# sourceMappingURL=InteractionEventManager.js.map