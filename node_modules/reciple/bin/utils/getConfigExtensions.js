"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConfigExtensions = exports.configMergeCustomizer = void 0;
const node_fs_1 = require("node:fs");
const client_1 = require("@reciple/client");
const lodash_mergewith_1 = __importDefault(require("lodash.mergewith"));
const node_path_1 = __importDefault(require("node:path"));
const yaml_1 = __importDefault(require("yaml"));
function configMergeCustomizer(objValue, srcValue, key) {
    if (Array.isArray(objValue))
        return srcValue;
}
exports.configMergeCustomizer = configMergeCustomizer;
function getConfigExtensions(config, configPath) {
    if (!config.extends || Array.isArray(config.extends) && !config.extends.length)
        return config;
    let extensions = typeof config.extends === 'string' ? [config.extends] : config.extends;
    extensions = extensions.map(e => configPath
        ? node_path_1.default.isAbsolute(e)
            ? e
            : node_path_1.default.join(node_path_1.default.dirname(configPath), e)
        : e);
    for (const extension of extensions) {
        if (!(0, node_fs_1.existsSync)(extension))
            throw new client_1.RecipleError({ message: `Config extension file doesn't exists: ${extension}`, name: 'InvalidConfigExtensionPath' });
        const configExtension = getConfigExtensions(yaml_1.default.parse((0, node_fs_1.readFileSync)(extension, 'utf-8')), extension);
        config = (0, lodash_mergewith_1.default)(configExtension, config, configMergeCustomizer);
    }
    config.extends = extensions;
    return config;
}
exports.getConfigExtensions = getConfigExtensions;
//# sourceMappingURL=getConfigExtensions.js.map