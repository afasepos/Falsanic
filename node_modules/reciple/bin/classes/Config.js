"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = void 0;
const client_1 = require("@reciple/client");
const discord_js_1 = require("discord.js");
const getConfigExtensions_1 = require("../utils/getConfigExtensions");
const promises_1 = require("node:fs/promises");
const parseEnvString_1 = require("../utils/parseEnvString");
const fallout_utility_1 = require("fallout-utility");
const node_fs_1 = require("node:fs");
const cli_1 = require("../utils/cli");
const node_path_1 = __importDefault(require("node:path"));
const dotenv_1 = __importDefault(require("dotenv"));
const yaml_1 = __importDefault(require("yaml"));
class Config {
    static defaultConfigPath = node_path_1.default.join(__dirname, '../../static/config.yml');
    config = null;
    configPath;
    extensionPaths = [];
    constructor(configPath, extensionPaths) {
        if (!configPath)
            throw new client_1.RecipleError({ message: 'Config path is not defined', name: 'InvalidConfigPath' });
        this.configPath = configPath;
        this.extensionPaths = extensionPaths ?? [];
    }
    async parseConfig() {
        if (!(0, node_fs_1.existsSync)(this.configPath)) {
            let configYaml = (0, fallout_utility_1.replaceAll)(Config.defaultConfigYaml(), 'VERSION', client_1.version);
            const configData = yaml_1.default.parse(configYaml);
            if (configData.token === 'TOKEN') {
                configData.token = cli_1.cli.options.token || (await this.askToken()) || 'TOKEN';
                configYaml = (0, fallout_utility_1.replaceAll)(configYaml, 'token: TOKEN', `token: ${configData.token}`);
            }
            await (0, promises_1.mkdir)(node_path_1.default.dirname(this.configPath), { recursive: true });
            await (0, promises_1.writeFile)(this.configPath, configYaml, 'utf-8');
            this.config = configData;
        }
        else {
            this.config = yaml_1.default.parse(await (0, promises_1.readFile)(this.configPath, 'utf-8'));
        }
        this.config.extends = (0, discord_js_1.normalizeArray)([this.config?.extends ?? []]);
        this.config.extends.push(...this.extensionPaths);
        this.config = (0, getConfigExtensions_1.getConfigExtensions)(this.config, this.configPath);
        return this;
    }
    getConfig() {
        if (!this.config)
            throw new client_1.RecipleError({ message: 'Config is not parsed', name: 'InvalidParsedConfigData' });
        this.config.token = this.parseToken() || 'TOKEN';
        return Config.resolveEnvValues(this.config);
    }
    async askToken() {
        return (await (await import('prompts')).default({
            name: 'token',
            type: 'password',
            mask: '*',
            message: 'Bot token:',
            validate: value => !value.length ? `Enter a valid bot token` : true
        }, { onCancel: () => process.exit(1) })).token;
    }
    parseToken() {
        const token = cli_1.cli.options.token || this.config?.token || null;
        if (!token)
            return token;
        return (0, parseEnvString_1.parseEnvString)(token, cli_1.cli.options.env ? node_path_1.default.resolve(cli_1.cli.options.env) : node_path_1.default.join(process.cwd(), '.env')) || null;
    }
    static resolveEnvValues(object, envFile) {
        if (envFile)
            dotenv_1.default.config({ path: envFile, override: true });
        if (typeof object !== 'object')
            return (typeof object === 'string' ? (0, parseEnvString_1.parseEnvString)(object) : object);
        if (Array.isArray(object))
            return object.map(v => (0, parseEnvString_1.parseEnvString)(v));
        const keys = object ? Object.keys(object) : [];
        const values = Object.values(object);
        let newObject = {};
        let i = 0;
        for (const value of values) {
            newObject = {
                ...newObject,
                [keys[i]]: typeof value === 'string' || typeof value === 'object'
                    ? this.resolveEnvValues(value)
                    : value
            };
            i++;
        }
        return newObject;
    }
    static defaultConfig() {
        return yaml_1.default.parse(this.defaultConfigYaml());
    }
    static defaultConfigYaml() {
        if (!(0, node_fs_1.existsSync)(this.defaultConfigPath))
            throw new client_1.RecipleError(`Default config file does not exists '${fallout_utility_1.kleur.yellow(this.defaultConfigPath)}'`);
        return (0, node_fs_1.readFileSync)(this.defaultConfigPath, 'utf-8');
    }
}
exports.Config = Config;
//# sourceMappingURL=Config.js.map