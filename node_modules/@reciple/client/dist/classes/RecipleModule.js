"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecipleModule = void 0;
const commands_1 = require("../types/commands");
const ContextMenuCommandBuilder_1 = require("./builders/ContextMenuCommandBuilder");
const MessageCommandBuilder_1 = require("./builders/MessageCommandBuilder");
const SlashCommandBuilder_1 = require("./builders/SlashCommandBuilder");
const CommandAssertions_1 = require("./assertions/CommandAssertions");
const discord_js_1 = require("discord.js");
const node_crypto_1 = require("node:crypto");
const semver_1 = __importDefault(require("semver"));
class RecipleModule {
    _script;
    id;
    client;
    filePath;
    commands = [];
    get script() { return this._script; }
    constructor(options) {
        this.filePath = options.filePath;
        this._script = options.script;
        this.client = options.client;
        this.id = (0, node_crypto_1.randomUUID)();
    }
    get versions() { return (0, discord_js_1.normalizeArray)([this.script.versions]); }
    get displayName() { return this.filePath ?? this.id; }
    get isSupported() { return this.versions.some(v => v === "latest" || semver_1.default.satisfies(this.client.version, v)); }
    async start() {
        return Promise.resolve(this.script.onStart(this.client, this));
    }
    async load(resolveCommands = true) {
        if (this.script.onLoad)
            await Promise.resolve(this.script.onLoad(this.client, this));
        if (resolveCommands)
            this.resolveCommands();
    }
    async unload(reason) {
        if (this.script.onUnload)
            await Promise.resolve(this.script.onUnload({
                client: this.client,
                module: this,
                reason
            }));
    }
    async contextMenuCommandPrecondition(execute) {
        return this._script.contextMenuCommandPrecondition ? await Promise.resolve(this._script.contextMenuCommandPrecondition(execute)) : true;
    }
    async messageCommandPrecondition(execute) {
        return this._script.messageCommandPrecondition ? await Promise.resolve(this._script.messageCommandPrecondition(execute)) : true;
    }
    async slashCommandPrecondition(execute) {
        return this._script.slashCommandPrecondition ? await Promise.resolve(this._script.slashCommandPrecondition(execute)) : true;
    }
    async executePrecondition(executeData) {
        return executeData.commandType === commands_1.CommandType.ContextMenuCommand
            ? this.contextMenuCommandPrecondition(executeData)
            : executeData.commandType === commands_1.CommandType.MessageCommand
                ? this.messageCommandPrecondition(executeData)
                : this.slashCommandPrecondition(executeData);
    }
    resolveCommands() {
        const commands = [];
        for (const commandData of (this._script.commands ?? [])) {
            let command;
            try {
                CommandAssertions_1.CommandAssertions.validateCommand(commandData);
            }
            catch (err) {
                this.client._throwError(err);
                continue;
            }
            switch (commandData.commandType) {
                case commands_1.CommandType.ContextMenuCommand:
                    command = ContextMenuCommandBuilder_1.ContextMenuCommandBuilder.resolve(commandData);
                    break;
                case commands_1.CommandType.MessageCommand:
                    command = MessageCommandBuilder_1.MessageCommandBuilder.resolve(commandData);
                    break;
                case commands_1.CommandType.SlashCommand:
                    command = SlashCommandBuilder_1.SlashCommandBuilder.resolve(commandData);
                    break;
            }
            if (command)
                commands.push(command);
        }
        this.commands = commands;
        return commands;
    }
    toString() {
        return this.displayName;
    }
}
exports.RecipleModule = RecipleModule;
//# sourceMappingURL=RecipleModule.js.map