"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecipleClient = void 0;
const commands_1 = require("../types/commands");
const discord_js_1 = __importDefault(require("discord.js"));
const CommandCooldownManager_1 = require("./managers/CommandCooldownManager");
const CommandManager_1 = require("./managers/CommandManager");
const ModuleManager_1 = require("./managers/ModuleManager");
const RecipleError_1 = require("./errors/RecipleError");
const halt_1 = require("../types/halt");
const constants_1 = require("../utils/constants");
class RecipleClient extends discord_js_1.default.Client {
    config;
    modules = new ModuleManager_1.ModuleManager({ client: this });
    commands = new CommandManager_1.CommandManager({ client: this });
    cooldowns = new CommandCooldownManager_1.CommandCooldownManager();
    logger;
    version = constants_1.version;
    constructor(options) {
        super({ ...options });
        this.config = options.recipleOptions;
        this.logger = options.logger;
        if (this.config?.cooldownSweeper?.enabled !== false) {
            this.cooldowns.setSweeperTimer(this.config?.cooldownSweeper?.interval ?? 3600000);
        }
        else {
            this.logger?.warn(`Cooldown sweeper is disabled! Some unused cooldowns will not be removed.`);
        }
    }
    isReady() {
        return super.isReady();
    }
    _throwError(error, throwWhenNoListener = true) {
        if (!this.listenerCount('recipleError')) {
            if (!throwWhenNoListener)
                return;
            throw error;
        }
        this.emit('recipleError', error);
    }
    async _haltCommand(command, haltData) {
        this.emit('recipleCommandHalt', haltData);
        const haltResolve = await Promise.resolve(command.halt
            ? command.commandType === commands_1.CommandType.ContextMenuCommand
                ? command.halt(haltData)
                : command.commandType === commands_1.CommandType.MessageCommand
                    ? command.halt(haltData)
                    : command.commandType === commands_1.CommandType.SlashCommand
                        ? command.halt(haltData)
                        : false
            : false)
            .catch(err => this._throwError(new RecipleError_1.RecipleError(RecipleError_1.RecipleError.createCommandHaltErrorOptions(command, err))));
        return haltResolve ?? true;
    }
    async _executeCommand(command, executeData) {
        if (!command.execute) {
            // @ts-expect-error Types is not usable here
            await this._haltCommand(command, { commandType: command.commandType, reason: halt_1.CommandHaltReason.NoExecuteHandler, executeData });
            return false;
        }
        return !!await Promise.resolve(command.commandType === commands_1.CommandType.ContextMenuCommand
            ? command.execute(executeData)
            : command.commandType === commands_1.CommandType.MessageCommand
                ? command.execute(executeData)
                : command.commandType === commands_1.CommandType.SlashCommand
                    ? command.execute(executeData)
                    : false)
            .then(() => this.emit('recipleCommandExecute', executeData))
            .catch(async (err) => {
            // @ts-expect-error Types is not usable here
            const isHandled = await this._haltCommand(command, { commandType: command.commandType, reason: halt_1.CommandHaltReason.Error, executeData, error: err });
            if (!isHandled)
                this._throwError(new RecipleError_1.RecipleError(RecipleError_1.RecipleError.createCommandExecuteErrorOptions(command, err)));
        });
    }
    async _executeCommandPrecondition(command, executeData) {
        const commandModule = this.modules.findCommandModule(command);
        const globalPrecondition = this.commands.getGlobalPrecondition(command.commandType);
        try {
            let isTrue = false;
            isTrue = await globalPrecondition(executeData);
            if (!isTrue || !commandModule)
                return isTrue;
            isTrue = await commandModule.executePrecondition(executeData);
            if (!isTrue)
                return isTrue;
            this.emit('recipleCommandPrecondition', executeData);
            return true;
        }
        catch (err) {
            // @ts-expect-error Types is not usable here
            const isHandled = await this._haltCommand(command, { commandType: command.commandType, reason: halt_1.CommandHaltReason.PreconditionError, executeData, error: err });
            if (!isHandled)
                this._throwError(new RecipleError_1.RecipleError(RecipleError_1.RecipleError.createCommandPreconditionErrorOptions(command, err)));
            return false;
        }
    }
    login(token) {
        this.config.token = token ?? this.config.token;
        return super.login(this.config.token);
    }
}
exports.RecipleClient = RecipleClient;
//# sourceMappingURL=RecipleClient.js.map