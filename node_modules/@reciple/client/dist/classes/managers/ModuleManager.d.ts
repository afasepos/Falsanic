import { Awaitable, Collection } from 'discord.js';
import { RecursiveDefault } from '../../utils/functions';
import { AnyCommandBuilder, AnyCommandData } from '../../types/commands';
import { RecipleModule, RecipleModuleScript } from '../RecipleModule';
import { RecipleClient } from '../RecipleClient';
import { TypedEmitter } from 'fallout-utility';
export interface ModuleManagerEvents {
    resolveModuleFileError: [file: string, error: Error];
    startModuleFailed: [module: RecipleModule];
    preStartModule: [module: RecipleModule];
    postStartModule: [module: RecipleModule];
    startModuleError: [module: RecipleModule, error: Error];
    startedModules: [modules: RecipleModule[]];
    preLoadModule: [module: RecipleModule];
    postLoadModule: [module: RecipleModule];
    loadModuleError: [module: RecipleModule, error: Error];
    loadedModules: [modules: RecipleModule[]];
    preUnloadModule: [module: RecipleModule];
    postUnloadModule: [module: RecipleModule];
    unloadModuleError: [module: RecipleModule, error: Error];
    unloadedModules: [modules: RecipleModule[]];
}
export interface ModuleManagerOptions {
    client: RecipleClient;
    modules?: (RecipleModule | RecipleModuleScript)[];
}
export interface ModuleManagerModulesActionOptions<S extends RecipleModuleScript = RecipleModuleScript> {
    modules: RecipleModule<S>[];
}
export declare class ModuleManager extends TypedEmitter<ModuleManagerEvents> {
    readonly client: RecipleClient;
    readonly cache: Collection<string, RecipleModule>;
    constructor(options: ModuleManagerOptions);
    /**
     * This method takes a command object and returns the module that contains the command. If the command is not found, the function returns undefined.
     */
    findCommandModule<S extends RecipleModuleScript = RecipleModuleScript>(command: AnyCommandData | AnyCommandBuilder): RecipleModule<S> | undefined;
    /**
     * This method starts the specified modules. The modules will be started in the order that they are specified.
     * @returns The started modules
     */
    startModules<S extends RecipleModuleScript = RecipleModuleScript>(options: ModuleManagerModulesActionOptions<S> & {
        addToModulesCollection?: boolean;
    }): Promise<RecipleModule<S>[]>;
    /**
     * This method loads the specified modules. The modules will be loaded in the order that they are specified.
     * @returns The loaded modules
     */
    loadModules<S extends RecipleModuleScript = RecipleModuleScript>(options: ModuleManagerModulesActionOptions<S> & {
        resolveCommands?: boolean;
    }): Promise<RecipleModule<S>[]>;
    /**
     * This method unloads the specified modules. The modules will be unloaded in the reverse order that they were loaded.
     * @returns The unloaded modules
     */
    unloadModules<S extends RecipleModuleScript = RecipleModuleScript>(options: ModuleManagerModulesActionOptions<S> & {
        reason?: string;
        removeFromModulesCollection?: boolean;
        removeCommandsFromClient?: boolean;
    }): Promise<RecipleModule<S>[]>;
    resolveModuleFiles<S extends RecipleModuleScript = RecipleModuleScript>(files: string[], disableVersionCheck?: boolean, fileResolver?: (filePath: string) => Awaitable<undefined | RecursiveDefault<RecipleModule<S> | S> | RecipleModule<S> | S>): Promise<RecipleModule<S>[]>;
    isRecipleModuleScript(script: unknown): script is RecipleModuleScript;
    /**
     * @deprecated Use the assertion method `RecipleModuleAssertions#validateModuleScript`
     */
    validateScript<S extends RecipleModuleScript = RecipleModuleScript>(script: unknown): asserts script is S;
    /**
     * @deprecated Use the ModuleManager.cache property instead
     */
    get modules(): Collection<string, RecipleModule<RecipleModuleScript>>;
    _throwError<E extends keyof ModuleManagerEvents>(error: Error, event: {
        name: E;
        values: ModuleManagerEvents[E];
    }, throwWhenNoListener?: boolean): void;
}
