"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandManager = void 0;
const discord_js_1 = require("discord.js");
const commands_1 = require("../../types/commands");
const SlashCommandBuilder_1 = require("../builders/SlashCommandBuilder");
const ContextMenuCommandBuilder_1 = require("../builders/ContextMenuCommandBuilder");
const MessageCommandBuilder_1 = require("../builders/MessageCommandBuilder");
const CommandAssertions_1 = require("../assertions/CommandAssertions");
const RecipleError_1 = require("../errors/RecipleError");
class CommandManager {
    client;
    contextMenuCommands = new discord_js_1.Collection();
    messageCommands = new discord_js_1.Collection();
    slashCommands = new discord_js_1.Collection();
    additionalApplicationCommands = [];
    globalContextMenuCommandPrecondition;
    globalMessageCommandPrecondition;
    globalSlashCommandPrecondition;
    get size() { return this.contextMenuCommands.size + this.messageCommands.size + this.slashCommands.size; }
    constructor(options) {
        this.client = options.client;
        options.contextMenuCommands?.forEach(c => this.contextMenuCommands.set(c.name, ContextMenuCommandBuilder_1.ContextMenuCommandBuilder.resolve(c)));
        options.messageCommands?.forEach(c => this.messageCommands.set(c.name, MessageCommandBuilder_1.MessageCommandBuilder.resolve(c)));
        options.slashCommands?.forEach(c => this.slashCommands.set(c.name, SlashCommandBuilder_1.SlashCommandBuilder.resolve(c)));
        this.additionalApplicationCommands = options.additionalApplicationCommands ?? [];
    }
    add(...commands) {
        commands = (0, discord_js_1.normalizeArray)(commands);
        commands.forEach(command => CommandAssertions_1.CommandAssertions.validateCommand(command));
        for (const command of commands) {
            switch (command.commandType) {
                case commands_1.CommandType.ContextMenuCommand:
                    if (this.client.config.commands?.contextMenuCommand?.enabled === false)
                        break;
                    this.contextMenuCommands.set(command.name, ContextMenuCommandBuilder_1.ContextMenuCommandBuilder.resolve(command));
                    break;
                case commands_1.CommandType.MessageCommand:
                    if (this.client.config.commands?.messageCommand?.enabled === false)
                        break;
                    this.messageCommands.set(command.name, MessageCommandBuilder_1.MessageCommandBuilder.resolve(command));
                    break;
                case commands_1.CommandType.SlashCommand:
                    if (this.client.config.commands?.slashCommand?.enabled === false)
                        break;
                    this.slashCommands.set(command.name, SlashCommandBuilder_1.SlashCommandBuilder.resolve(command));
                    break;
                default:
                    throw new RecipleError_1.RecipleError(RecipleError_1.RecipleError.createUnknownCommandTypeErrorOptions(command));
            }
        }
        return this;
    }
    addAdditionalApplicationCommands(...commands) {
        for (const command of (0, discord_js_1.normalizeArray)(commands)) {
            this.additionalApplicationCommands.push(command);
        }
        return this;
    }
    setGlobalPrecondition(commandType, precondition) {
        precondition = precondition || undefined;
        switch (commandType) {
            case commands_1.CommandType.ContextMenuCommand:
                this.globalContextMenuCommandPrecondition = precondition;
                break;
            case commands_1.CommandType.MessageCommand:
                this.globalMessageCommandPrecondition = precondition;
                break;
            case commands_1.CommandType.SlashCommand:
                this.globalSlashCommandPrecondition = precondition;
                break;
        }
    }
    getGlobalPrecondition(commandType) {
        switch (commandType) {
            case commands_1.CommandType.ContextMenuCommand:
                return this.globalContextMenuCommandPrecondition || (() => true);
            case commands_1.CommandType.MessageCommand:
                return this.globalMessageCommandPrecondition || (() => true);
            case commands_1.CommandType.SlashCommand:
                return this.globalSlashCommandPrecondition || (() => true);
        }
    }
    get(command, type) {
        switch (type) {
            case commands_1.CommandType.ContextMenuCommand:
                return this.contextMenuCommands.get(command);
            case commands_1.CommandType.MessageCommand:
                return (this.messageCommands.get(command) ?? this.messageCommands.find(c => c.aliases.some(a => a == command?.toLowerCase())));
            case commands_1.CommandType.SlashCommand:
                return this.slashCommands.get(command);
            default:
                throw new TypeError('Unknown command type');
        }
    }
    async registerApplicationCommands(options) {
        const store = { global: new discord_js_1.Collection(), guilds: new discord_js_1.Collection() };
        const config = (0, discord_js_1.mergeDefault)({ ...this.client.config.commands, ...this.client.config.applicationCommandRegister }, options);
        if (config?.enabled === false)
            return store;
        const contextMenuCommands = this._parseApplicationCommands(options?.contextMenus?.commands ?? [...this.contextMenuCommands.values()]);
        const slashCommands = this._parseApplicationCommands(options?.slashCommands?.commands ?? [...this.slashCommands.values()]);
        const additionalApplicationCommands = this._parseApplicationCommands(options?.additionalApplicationCommands?.commands ?? [...this.additionalApplicationCommands]);
        const globalCommands = [];
        const guildCommands = new discord_js_1.Collection();
        if (config.allowRegisterGlobally !== false) {
            if (config.contextMenus?.registerCommands?.registerGlobally !== false)
                globalCommands.push(...contextMenuCommands);
            if (config.slashCommands?.registerCommands?.registerGlobally !== false)
                globalCommands.push(...slashCommands);
            if (config.additionalApplicationCommands?.registerCommands?.registerGlobally !== false)
                globalCommands.push(...additionalApplicationCommands);
        }
        if (config.allowRegisterToGuilds ?? config.allowRegisterOnGuilds) {
            for (const guildId of config.contextMenus?.registerCommands?.registerToGuilds ?? []) {
                const commands = guildCommands.get(guildId) ?? guildCommands.set(guildId, new Set()).get(guildId);
                contextMenuCommands.forEach(c => commands.add(c));
            }
            for (const guildId of config.slashCommands?.registerCommands?.registerToGuilds ?? []) {
                const commands = guildCommands.get(guildId) ?? guildCommands.set(guildId, new Set()).get(guildId);
                slashCommands.forEach(c => commands.add(c));
            }
            for (const guildId of config.additionalApplicationCommands?.registerCommands?.registerToGuilds ?? []) {
                const commands = guildCommands.get(guildId) ?? guildCommands.set(guildId, new Set()).get(guildId);
                additionalApplicationCommands.forEach(c => commands.add(c));
            }
            for (const guildId of config.registerToGuilds ?? []) {
                const commands = guildCommands.get(guildId) ?? guildCommands.set(guildId, new Set()).get(guildId);
                [...contextMenuCommands, ...slashCommands, ...additionalApplicationCommands].forEach(c => commands.add(c));
            }
        }
        if (config.allowRegisterGlobally !== false && (config.registerEmptyCommands || globalCommands.length)) {
            const commands = await this.client.application.commands.set(globalCommands)
                .then(cmds => {
                this.client.emit('recipleRegisterApplicationCommands', cmds);
                return cmds;
            })
                .catch(err => this.client._throwError(err));
            if (commands)
                commands.forEach(c => store.global.set(c.id, c));
        }
        if (config.allowRegisterToGuilds ?? config.allowRegisterOnGuilds) {
            for (const [guildId, APIcommands] of guildCommands) {
                if (!config.registerEmptyCommands && !APIcommands.size)
                    continue;
                const commands = await this.client.application.commands.set([...APIcommands.values()], guildId)
                    .then(cmds => {
                    this.client.emit('recipleRegisterApplicationCommands', cmds, guildId);
                    return cmds;
                })
                    .catch(err => this.client._throwError(err));
                store.guilds.set(guildId, commands ?? new discord_js_1.Collection());
            }
        }
        return store;
    }
    async execute(trigger) {
        if (trigger instanceof discord_js_1.ContextMenuCommandInteraction) {
            return ContextMenuCommandBuilder_1.ContextMenuCommandBuilder.execute(this.client, trigger);
        }
        else if (trigger instanceof discord_js_1.Message) {
            return MessageCommandBuilder_1.MessageCommandBuilder.execute(this.client, trigger);
        }
        else if (trigger instanceof discord_js_1.ChatInputCommandInteraction) {
            return SlashCommandBuilder_1.SlashCommandBuilder.execute(this.client, trigger);
        }
    }
    getApplicationCommand(command, guildId) {
        const name = typeof command === 'string' ? command : command.name;
        return this.client.application?.commands.cache.find(c => c.name === name && (guildId ? c.guildId === guildId : c.guildId === null));
    }
    async fetchApplicationCommand(command, guildId) {
        const name = typeof command === 'string' ? command : command.name;
        const commands = await this.client.application?.commands.fetch({ guildId });
        return commands?.find(c => c.name !== name);
    }
    _parseApplicationCommands(commands) {
        return commands.map(cmd => {
            if (cmd?.toJSON === undefined)
                return cmd;
            const data = cmd.toJSON();
            data.requiredBotPermissions = undefined;
            data.requiredMemberPermissions = undefined;
            data.execute = undefined;
            data.halt = undefined;
            return data;
        });
    }
}
exports.CommandManager = CommandManager;
//# sourceMappingURL=CommandManager.js.map