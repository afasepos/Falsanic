"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleManager = void 0;
const discord_js_1 = require("discord.js");
const RecipleModuleAssertions_1 = require("../assertions/RecipleModuleAssertions");
const functions_1 = require("../../utils/functions");
const RecipleModule_1 = require("../RecipleModule");
const RecipleError_1 = require("../errors/RecipleError");
const ModuleError_1 = require("../errors/ModuleError");
const fallout_utility_1 = require("fallout-utility");
const node_util_1 = require("node:util");
const node_path_1 = __importDefault(require("node:path"));
const semver_1 = __importDefault(require("semver"));
class ModuleManager extends fallout_utility_1.TypedEmitter {
    client;
    cache = new discord_js_1.Collection();
    constructor(options) {
        super();
        this.client = options.client;
        options.modules?.forEach(m => m instanceof RecipleModule_1.RecipleModule ? this.cache.set(m.id, m) : new RecipleModule_1.RecipleModule({ client: this.client, script: m }));
        this.validateScript = (0, node_util_1.deprecate)(this.validateScript, '<ModuleManager>.validateScript() is deprecated. Use RecipleModuleAssertions.validateModuleScript() method instead.');
    }
    /**
     * This method takes a command object and returns the module that contains the command. If the command is not found, the function returns undefined.
     */
    findCommandModule(command) {
        return this.cache.find(m => m.commands.some(c => c.commandType === command.commandType && c.name === command.name));
    }
    /**
     * This method starts the specified modules. The modules will be started in the order that they are specified.
     * @returns The started modules
     */
    async startModules(options) {
        const startModules = [];
        for (const module_ of options.modules) {
            this.emit('preStartModule', module_);
            try {
                let error = null;
                const start = await module_.start().catch(err => {
                    error = err;
                    return false;
                });
                if (error)
                    throw new RecipleError_1.RecipleError(RecipleError_1.RecipleError.createLoadModuleFailErrorOptions(module_.displayName, error));
                if (!start) {
                    this.emit('startModuleFailed', module_);
                    continue;
                }
                if (options.addToModulesCollection !== false)
                    this.cache.set(module_.id, module_);
                startModules.push(module_);
                this.emit('postStartModule', module_);
            }
            catch (err) {
                this._throwError(err, { name: 'startModuleError', values: [module_, err] });
            }
        }
        this.emit('startedModules', startModules);
        return startModules;
    }
    /**
     * This method loads the specified modules. The modules will be loaded in the order that they are specified.
     * @returns The loaded modules
     */
    async loadModules(options) {
        const loadedModules = [];
        for (const module_ of options.modules) {
            this.emit('preLoadModule', module_);
            try {
                await module_.load(options.resolveCommands !== false);
                if (module_.commands.length)
                    this.client.commands.add(...module_.commands);
                this.emit('postLoadModule', module_);
                loadedModules.push(module_);
            }
            catch (err) {
                this._throwError(err, { name: 'loadModuleError', values: [module_, err] });
            }
        }
        this.emit('loadedModules', loadedModules);
        return loadedModules;
    }
    /**
     * This method unloads the specified modules. The modules will be unloaded in the reverse order that they were loaded.
     * @returns The unloaded modules
     */
    async unloadModules(options) {
        const unloadedModules = [];
        for (const module_ of options.modules) {
            this.emit('preUnloadModule', module_);
            try {
                await module_.unload(options.reason);
                if (options.removeCommandsFromClient !== false) {
                    for (const cmd of module_.commands) {
                        if (cmd.isContextMenu()) {
                            this.client.commands.contextMenuCommands.delete(cmd.name);
                            const applicationCommands = this.client.application?.commands.cache.filter(c => c.name === cmd.name && (c.type === discord_js_1.ApplicationCommandType.Message || c.type === discord_js_1.ApplicationCommandType.User)).values();
                            for (const applicationCommand of (applicationCommands ?? [])) {
                                await this.client.application?.commands.delete(applicationCommand, applicationCommand.guildId || undefined);
                            }
                        }
                        else if (cmd.isMessageCommand()) {
                            this.client.commands.messageCommands.delete(cmd.name);
                        }
                        else if (cmd.isSlashCommand()) {
                            this.client.commands.slashCommands.delete(cmd.name);
                            const applicationCommands = this.client.application?.commands.cache.filter(c => c.name === cmd.name && c.type === discord_js_1.ApplicationCommandType.ChatInput).values();
                            for (const applicationCommand of (applicationCommands ?? [])) {
                                await this.client.application?.commands.delete(applicationCommand, applicationCommand.guildId || undefined);
                            }
                        }
                    }
                }
                if (options.removeFromModulesCollection !== false)
                    this.cache.delete(module_.id);
                this.emit('postUnloadModule', module_);
                unloadedModules.push(module_);
            }
            catch (err) {
                this._throwError(err, { name: 'unloadModuleError', values: [module_, err] });
            }
        }
        this.emit('unloadedModules', unloadedModules);
        return unloadedModules;
    }
    async resolveModuleFiles(files, disableVersionCheck = false, fileResolver) {
        const modules = [];
        for (const file of files) {
            const filePath = node_path_1.default.resolve(file);
            try {
                let resolveFile = fileResolver ? await Promise.resolve(fileResolver(filePath)) : undefined;
                resolveFile = resolveFile === undefined ? await import(`file://${filePath}`) : resolveFile;
                const script = (0, functions_1.recursiveDefaults)(resolveFile);
                if (script instanceof RecipleModule_1.RecipleModule) {
                    if (!disableVersionCheck && !script.isSupported)
                        throw new RecipleError_1.RecipleError(RecipleError_1.RecipleError.createUnsupportedModuleErrorOptions(script.displayName));
                    modules.push(script);
                    continue;
                }
                RecipleModuleAssertions_1.RecipleModuleAssertions.validateModuleScript(script);
                if (!disableVersionCheck && !(0, discord_js_1.normalizeArray)([script.versions])?.some(v => v === "latest" || semver_1.default.satisfies(this.client.version, v))) {
                    throw new RecipleError_1.RecipleError(RecipleError_1.RecipleError.createUnsupportedModuleErrorOptions(filePath));
                }
                modules.push(new RecipleModule_1.RecipleModule({
                    client: this.client,
                    script,
                    filePath,
                }));
            }
            catch (err) {
                this._throwError(err, { name: 'resolveModuleFileError', values: [filePath, err] });
            }
        }
        return modules;
    }
    isRecipleModuleScript(script) {
        try {
            RecipleModuleAssertions_1.RecipleModuleAssertions.validateModuleScript(script);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    // TODO: Remove deprecated
    /**
     * @deprecated Use the assertion method `RecipleModuleAssertions#validateModuleScript`
     */
    validateScript(script) {
        const s = script;
        if (typeof s !== 'object')
            return this.client._throwError(new ModuleError_1.ModuleError('InvalidScript'));
        if (typeof s.versions !== 'string' && !Array.isArray(s.versions))
            return this.client._throwError(new ModuleError_1.ModuleError(`NoSupportedVersions`));
        if (typeof s.onStart !== 'function')
            return this.client._throwError(new ModuleError_1.ModuleError('InvalidOnStartEvent'));
        if (s.onLoad && typeof s.onLoad !== 'function')
            return this.client._throwError(new ModuleError_1.ModuleError('InvalidOnLoadEvent'));
        if (s.onUnload && typeof s.onUnload !== 'function')
            return this.client._throwError(new ModuleError_1.ModuleError('InvalidOnUnloadEvent'));
    }
    /**
     * @deprecated Use the ModuleManager.cache property instead
     */
    get modules() { return this.cache; }
    _throwError(error, event, throwWhenNoListener = true) {
        if (!this.listenerCount(event.name)) {
            if (!throwWhenNoListener)
                return;
            throw error;
        }
        this.emit(event.name, ...event.values);
    }
}
exports.ModuleManager = ModuleManager;
//# sourceMappingURL=ModuleManager.js.map