"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageCommandBuilder = void 0;
const MessageCommandOptionBuilder_1 = require("./MessageCommandOptionBuilder");
const permissions_1 = require("../../utils/permissions");
const MessageCommandOptionManager_1 = require("../managers/MessageCommandOptionManager");
const BaseCommandBuilder_1 = require("./BaseCommandBuilder");
const discord_js_1 = require("discord.js");
const halt_1 = require("../../types/halt");
const commands_1 = require("../../types/commands");
const fallout_utility_1 = require("fallout-utility");
class MessageCommandBuilder extends BaseCommandBuilder_1.BaseCommandBuilder {
    commandType = commands_1.CommandType.MessageCommand;
    name = '';
    aliases = [];
    description = '';
    validateOptions = false;
    dmPermission = false;
    userBotPermission = false;
    options = [];
    constructor(data) {
        super(data);
        if (data?.name !== undefined)
            this.setName(data.name);
        if (data?.aliases !== undefined)
            this.setAliases(data.aliases);
        if (data?.description !== undefined)
            this.setDescription(data.description);
        if (data?.dmPermission !== undefined)
            this.setDmPermission(data.dmPermission);
        if (data?.userBotPermission !== undefined)
            this.setUserBotPermission(data.userBotPermission);
        if (data?.validateOptions !== undefined)
            this.setValidateOptions(data.validateOptions);
        if (data?.options !== undefined)
            this.setOptions(data.options);
    }
    /**
     * Sets the name of the command.
     * @param name The command name
     */
    setName(name) {
        this.name = name;
        return this;
    }
    /**
     * Adds aliases to the command.
     * @param aliases The command aliases
     */
    addAliases(...aliases) {
        aliases = (0, discord_js_1.normalizeArray)(aliases);
        if (aliases.some(a => !a || typeof a !== 'string' || a.match(/^\s+$/)))
            throw new TypeError('Aliases must be strings and should not contain whitespaces');
        if (this.name && aliases.some(a => a == this.name))
            throw new TypeError('Aliases cannot have same name to its real command name');
        this.aliases = [...new Set(aliases.map(s => s.toLowerCase()))];
        return this;
    }
    /**
     * Sets the aliases for the command
     * @param aliases The command aliases
     */
    setAliases(...aliases) {
        this.aliases = [];
        return this.addAliases(...aliases);
    }
    /**
     * Sets whether the command can be used in direct messages.
     * @param dmPermission Is allowed in DM
     */
    setDmPermission(dmPermission) {
        this.dmPermission = dmPermission;
        return this;
    }
    /**
     * Sets whether the command can be executed by bots.
     * @param userBotPermission Is executable by bots
     */
    setUserBotPermission(userBotPermission) {
        this.userBotPermission = userBotPermission;
        return this;
    }
    /**
     * Sets whether the command options should be validated.
     * @param validateOptions Is command options validate enabled
     */
    setValidateOptions(validateOptions) {
        this.validateOptions = validateOptions;
        return this;
    }
    /**
     * Sets the description of the command.
     * @param description The command description
     */
    setDescription(description) {
        this.description = description;
        return this;
    }
    /**
     * Adds options to the command.
     * @param options The command options
     */
    addOptions(...options) {
        for (const optionResolvable of (0, discord_js_1.normalizeArray)(options)) {
            this.addOption(optionResolvable);
        }
        return this;
    }
    /**
     * Sets options to the command.
     * @param options The command options
     */
    setOptions(...options) {
        this.options = [];
        return this.addOptions((0, discord_js_1.normalizeArray)(options));
    }
    /**
     * Add a single option to the command.
     * @param optionResolvable The command option
     */
    addOption(optionResolvable) {
        const option = typeof optionResolvable === 'function'
            ? optionResolvable(new MessageCommandOptionBuilder_1.MessageCommandOptionBuilder())
            : MessageCommandOptionBuilder_1.MessageCommandOptionBuilder.resolve(optionResolvable);
        if (this.options.find(o => o.name === option.name))
            throw new TypeError('An option with name "' + option.name + '" already exists.');
        if (this.options.length > 0 && !this.options[this.options.length - 1 < 0 ? 0 : this.options.length - 1].required && option.required)
            throw new TypeError('All required options must be before optional options.');
        this.options.push(option);
        return this;
    }
    toJSON() {
        return {
            ...super.toCommandData(),
            commandType: this.commandType,
            name: this.name,
            aliases: this.aliases,
            description: this.description,
            validateOptions: this.validateOptions,
            dmPermission: this.dmPermission,
            userBotPermission: this.userBotPermission,
            options: this.options.map(o => o.toJSON()),
            halt: this.halt,
            execute: this.execute
        };
    }
    /**
     * Resolve message command data and returns a builder
     * @param messageCommandResolvable The message command data
     */
    static resolve(messageCommandResolvable) {
        return this.isMessageCommandBuilder(messageCommandResolvable) ? messageCommandResolvable : new MessageCommandBuilder(messageCommandResolvable);
    }
    static isMessageCommandBuilder(data) {
        return data instanceof MessageCommandBuilder;
    }
    /**
     * Get validated command option values
     * @param options Validate options data
     */
    static async validateCommandOptions(options) {
        const validated = new MessageCommandOptionManager_1.MessageCommandOptionManager();
        if (!options.command.options)
            return validated;
        for (let i = 0; i < options.command.options.length; i++) {
            const arg = options.args[i];
            validated.set(options.command.options[i].name, await MessageCommandOptionBuilder_1.MessageCommandOptionBuilder.validateOptionValue(options.command.options[i], options.message, arg));
        }
        return validated;
    }
    /**
     * Execute a message command
     * @param client Current bot client
     * @param message The command message
     * @param prefix The command prefix
     * @param separator The command args separator
     * @param command Command builder resolvable of the command you wanna execute
     */
    static async execute(client, message, prefix, separator, command) {
        if (client.config.commands?.messageCommand?.enabled === false || !message.content)
            return;
        const commandData = (0, fallout_utility_1.getCommand)(message.content, prefix ?? client.config.commands?.messageCommand?.prefix ?? '!', separator ?? client.config.commands?.messageCommand?.commandArgumentSeparator ?? ' ');
        if (!commandData || !commandData.name)
            return;
        const builder = command ? this.resolve(command) : client.commands.get(commandData.name, commands_1.CommandType.MessageCommand);
        if (!builder || (!builder.dmPermission && !message.inGuild()) || (!builder.userBotPermission && (message.author.bot || message.author.system)))
            return;
        const executeData = {
            commandType: builder.commandType,
            builder,
            command: commandData,
            message,
            options: null,
            client
        };
        const commandOptions = await MessageCommandBuilder.validateCommandOptions({
            client,
            message,
            command: builder,
            args: commandData.args
        }).catch((err) => err);
        if (commandOptions instanceof Error) {
            const isHandled = await client._haltCommand(builder, {
                commandType: builder.commandType,
                reason: halt_1.CommandHaltReason.ValidateOptionError,
                error: commandOptions,
                executeData
            });
            if (!isHandled)
                client._throwError(commandOptions);
            return;
        }
        executeData.options = commandOptions;
        if (client.config.commands?.slashCommand?.enableCooldown !== false && builder.cooldown) {
            const cooldownData = {
                command: builder.name,
                user: message.author,
                type: builder.commandType
            };
            if (!client.cooldowns.isCooledDown(cooldownData)) {
                client.cooldowns.add({ ...cooldownData, endsAt: new Date(Date.now() + builder.cooldown) });
            }
            else {
                await client._haltCommand(builder, {
                    commandType: builder.commandType,
                    reason: halt_1.CommandHaltReason.Cooldown,
                    cooldownData: client.cooldowns.get(cooldownData),
                    executeData
                });
                return;
            }
        }
        if (!message.inGuild() && message.member?.permissions && builder.requiredMemberPermissions && (0, permissions_1.hasExecutePermissions)({ builder, memberPermissions: message.member?.permissions })) {
            await client._haltCommand(builder, {
                commandType: builder.commandType,
                reason: halt_1.CommandHaltReason.MissingMemberPermissions,
                executeData
            });
            return;
        }
        if (builder.validateOptions) {
            if (commandOptions.some(o => o.invalid)) {
                await client._haltCommand(builder, {
                    commandType: builder.commandType,
                    reason: halt_1.CommandHaltReason.InvalidArguments,
                    executeData,
                    invalidArguments: new MessageCommandOptionManager_1.MessageCommandOptionManager(commandOptions.filter(o => o.invalid).map(o => [o.name, o]))
                });
                return;
            }
            if (commandOptions.some(o => o.missing)) {
                await client._haltCommand(builder, {
                    commandType: builder.commandType,
                    reason: halt_1.CommandHaltReason.MissingArguments,
                    executeData,
                    missingArguments: new MessageCommandOptionManager_1.MessageCommandOptionManager(commandOptions.filter(o => o.missing).map(o => [o.name, o]))
                });
                return;
            }
        }
        if (builder.requiredBotPermissions && message.inGuild()) {
            const isBotExecuteAllowed = (0, permissions_1.botHasPermissionsToExecute)((message.channel || message.guild), builder.requiredBotPermissions);
            if (!isBotExecuteAllowed) {
                await client._haltCommand(builder, {
                    commandType: builder.commandType,
                    reason: halt_1.CommandHaltReason.MissingBotPermissions,
                    executeData
                });
                return;
            }
        }
        const precondition = await client._executeCommandPrecondition(builder, executeData);
        if (!precondition)
            return;
        return (await client._executeCommand(builder, executeData)) ? executeData : undefined;
    }
}
exports.MessageCommandBuilder = MessageCommandBuilder;
//# sourceMappingURL=MessageCommandBuilder.js.map