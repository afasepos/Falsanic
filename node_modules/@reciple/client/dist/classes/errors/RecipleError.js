"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecipleError = void 0;
const node_util_1 = require("node:util");
const functions_1 = require("../../utils/functions");
const constants_1 = require("../../utils/constants");
const fallout_utility_1 = require("fallout-utility");
class RecipleError extends Error {
    get cleanStack() { return this.stack && (0, node_util_1.stripVTControlCharacters)(this.stack); }
    constructor(options) {
        options = typeof options === 'string' ? { message: options } : options;
        super(options.message, { ...options });
        if (options.name)
            this.name = fallout_utility_1.kleur.bold().red(options.name);
    }
    toString() {
        return (0, node_util_1.stripVTControlCharacters)(super.toString());
    }
    static createUnknownCommandTypeErrorOptions(given) {
        return {
            message: `Unknown command type ${fallout_utility_1.kleur.blue().bold(typeof given)}`,
            name: 'UnknownCommandType'
        };
    }
    static createCommandExecuteErrorOptions(builder, cause) {
        return {
            message: `An error occured while executing a ${fallout_utility_1.kleur.cyan((0, functions_1.getCommandBuilderName)(builder))} named ${fallout_utility_1.kleur.red("'" + builder.name + "'")}`,
            cause,
            name: 'CommandExecuteError'
        };
    }
    static createCommandHaltErrorOptions(builder, cause) {
        return {
            message: `An error occured while executing the halt function of a ${fallout_utility_1.kleur.cyan((0, functions_1.getCommandBuilderName)(builder))} named ${fallout_utility_1.kleur.red("'" + builder.name + "'")}`,
            cause,
            name: 'CommandHaltError'
        };
    }
    static createCommandPreconditionErrorOptions(builder, cause) {
        return {
            message: `An error occured while executing precondition for ${fallout_utility_1.kleur.cyan((0, functions_1.getCommandBuilderName)(builder))} named ${fallout_utility_1.kleur.red("'" + builder.name + "'")}`,
            cause,
            name: 'PreconditionError'
        };
    }
    static createCommandRequiredOptionNotFoundErrorOptions(optionName, value) {
        return {
            message: `No value given from required option ${fallout_utility_1.kleur.cyan("'" + optionName + "'")}`,
            cause: { value },
            name: 'RequiredOptionNotFound'
        };
    }
    static createLoadModuleFailErrorOptions(moduleDisplayName, cause) {
        return {
            message: `Failed to load ${fallout_utility_1.kleur.red("'" + moduleDisplayName + "'")}`,
            cause,
            name: 'LoadModuleFail'
        };
    }
    static createUnsupportedModuleErrorOptions(moduleDisplayName) {
        return {
            message: `The module ${fallout_utility_1.kleur.red("'" + moduleDisplayName + "'")} does not support reciple client ${fallout_utility_1.kleur.blue().bold(constants_1.realVersion)}`,
            name: 'UnsupportedModule'
        };
    }
}
exports.RecipleError = RecipleError;
//# sourceMappingURL=RecipleError.js.map